java高级并发

第一章

并发级别

1. 阻塞（Blocking）：一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行，
当我们使用synchronized关键字，或者重入锁时，我们得到的就是阻塞的线程

2.无饥饿（starvation-free）
如果线程之间是有优先级的，那么线程调度的时候总会倾向于满足优先级高的线程，对于同一资源的分配，
是不公平的。对于非公平的锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级的线程
产生饥饿。

3.无障碍（obstruction-free）
最弱的非阻塞调度，非阻塞调度是一种乐观的策略，认为多个线程之间爱你有可能不会发生冲突，或者
这种概率不大。

4.无锁（Lock-free）
无锁的并行都是无障碍的，在无锁的情况下，所有的线程都能尝试对临界区进行访问，但是不同的是，无锁的并发保证必然有
一个线程能够在有限的步骤内完成操作离开临界区。

5.无等待（Wait-free）
无等待则在无锁的基础上更进一步进行扩展，要求所有线程必须在有限步骤内完成，这样就不会引起
饥饿问题。
一种典型的无等待问题就是RCU（Read-Copy-Update），其基本思想是对数据的可读不加控制，因此
所有的线程都是无等待的，它们既不会锁定等待，也不会引起任何冲突。但是在写数据时，，先取得
原始数据的副本，接着只修改副本数据，修改完成之后，在合适的时机写数据。

JMM：java内存模型

关键技术是围绕着多线程的原子性、可见性和有序性来建立的

原子性：指一个操作是不可中断的，一个操作一旦开始，就不会被其他线程干扰
