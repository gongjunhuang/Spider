面试

装饰器
本质是函数，不需要做改动的前提下额外增加功能
def use_logggin(func):
	def wrapper():
		print('this is %s running'%func.__name__)
		return func()
	return wrapper


单例模式

class Singleton(object):
	def __new__(cls, *args, **kwargs):
		if not hasattr(cls, '_instance'):
			orig = super(Singleton, cls)
			cls._instance = orig.__new__(cls, *args, **kwargs)
		return cls._instance

copy：复制的地址
deepcopy：重新开辟一块内存，对资源进行拷贝


二分查找

def binary_search(list, item):
	low = 0, high = len(list-1)
	while(low < high):
		mid = (low+high)/2
		guess = list[mid]
		if guess > item:
			high = mid - 1
		elif guess < item:
			low = mid + 1
		else:
			return mid
	return None



冒泡排序

def bubble_sort(list):
	length = len(list)
	for i in range(length):
		for j in range(0, length-i-1):
			if list[j] > list[j+1]:
				list[j], list[j+1] = list[j+1], list[j]

	return list


快速排序

def quicksort(list):
	if len(list) < 2:
		return list
	else:
		midpivot = list[0]
		lessbefore = [i for i in list[1:] if i < midpivot]
		bigafter = [i for i in list[1:] if i > midpivot]
		final = quicksort(lessbefore) + [midpivot] + quicksort(bigafter)
		return final


选择排序

def selectsort(list):
	length = len(list)
	for i in range(length):
		min_index = i
		for j in range(i+1, length):
			if list[j] < list[min_index]:
				min_index = j
		list[i], list[min_index] = list[min_index], list[i]
	return list


插入排序

def insetsort(list):
	length = len(list)
	for i in range(1, length):
		for j in range(i):
			if list[i] < list[j]:
				list.insert(j, list[i])
				list.pop(i+1)
				break
	return list


归并排序

def merge(left, right):
	result = []
	while left and right:
		result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))
	while left:
		result.append(left.pop(0))
	while right:
		result.append(right.pop(0))

def mergeSort(list):
	if len(list) <= 1:
		return list
	left = mergeSort(list[0:len(list)/2])
	right = mergeSort(list[len(list)/2:])
	return merge(left, right)






