背包问题

动态规划的核心过程有两部分，一个是找出问题的”子状态”，再一个就是建立“状态转移方程”（所谓的递推公式）。将上面的问题解决，动态规划就解了一般，剩下的为代码将数学的公式的进行实现。 
- 动态规划的思路。先将原始问题一般化，欲求背包能够获得的总价值，即欲求前i个物体放入容量为m（kg）背包的最大价值c[i][m]——使用一个数组来存储最大价值，当m取10，i取3时，即原始问题了。而前i个物体放入容量为m（kg）的背包，又可以转化成前(i-1)个物体放入背包的问题。下面使用数学表达式描述它们两者之间的具体关系。 
- w[i]：第i个物体的重量 
- p[i]：第i个物体的价值 
- c[i][j]：前i个物体放入容量为j 包的最大价值 
- c[i-1][j]：前i个物体放入容量为j 包的最大价值 
- c[i-1][j-w[i]]：前i-1个物体放入容量为j-w[i] 包的最大价值

状态转移方程 
c[i][m]=max{c[i-1][m-w[i]]+p[i]（m>w[i]） , c[i-1][m]} 


'''
#n：物品件数；c:最大承重为c的背包；w:各个物品的重量；v:各个物品的价值
#第一步建立最大价值矩阵(横坐标表示[0,c]整数背包承重):(n+1)*(c+1)
#技巧:python 生成二维数组(数组)通常先生成列再生成行
def bag(n,c,w,p)：
    res=[[-1 for j in range(c+1)]for i in range(n+1)]
    for j in range(c+1):
        #第0行全部赋值为0，物品编号从1开始.为了下面赋值方便
        res[0][j]=0
    for i in range(1:n+1):
        for j in range(1:c+1):
            res[i][j]=res[i-1][j]
            #生成了n*c有效矩阵，以下公式w[i-1],p[i-1]代表从第一个元素w[0],p[0]开始取。
            if(j>=w[i-1]) and res[i-1][j-w[i-1]]+p[i-1]>res[i][j]：
                res[i][j]=res[i-1][j-w[i-1]]+p[i-1]
    return res
#以下代码功能：标记出有放入背包的物品
#反过来标记，在相同价值情况下，后一件物品比前一件物品的最大价值大，则表示物品i#有被加入到背包，x数组设置为True。设初始为j=c。
def show(n,c,w,res):  
    print('最大价值为:',res[n][c])  
    x=[False for i in range(n)]  
    j=c  
    for i in range(1,n+1):  
        if res[i][j]>res[i-1][j]:  
            x[i-1]=True  
            j-=w[i-1]  
    print '选择的物品为:'  
    for i in range(n):  
        if x[i]:  
            print '第',i,'个,' 
    print'' 
if __name__=='__main__':  
    n=5  
    c=10  
    w=[2,2,6,5,4]  
    p=[6,3,5,4,6]  
    res=bag(n,c,w,p)  
    show(n,c,w,res)
'''