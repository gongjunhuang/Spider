1. 基于Hierarchical Softmax的模型概述
　　　　我们先回顾下传统的神经网络词向量语言模型，里面一般有三层，输入层（词向量），隐藏层和输出层（softmax层）。里面最大的问题在于从隐藏层到输出的softmax层的计算量很大，因为要计算所有词的softmax概率，再去找概率最大的值。这个模型如下图所示。其中VV是词汇表的大小，



 

　　　　word2vec对这个模型做了改进，首先，对于从输入层到隐藏层的映射，没有采取神经网络的线性变换加激活函数的方法，而是采用简单的对所有输入词向量求和并取平均的方法。比如输入的是三个4维词向量：(1,2,3,4),(9,6,11,8),(5,10,7,12)(1,2,3,4),(9,6,11,8),(5,10,7,12),那么我们word2vec映射后的词向量就是(5,6,7,8)(5,6,7,8)。由于这里是从多个词向量变成了一个词向量。

　　　　第二个改进就是从隐藏层到输出的softmax层这里的计算量个改进。为了避免要计算所有词的softmax概率，word2vec采样了霍夫曼树来代替从隐藏层到输出softmax层的映射。我们在上一节已经介绍了霍夫曼树的原理。如何映射呢？这里就是理解word2vec的关键所在了。

　　　　由于我们把之前所有都要计算的从输出softmax层的概率计算变成了一颗二叉霍夫曼树，那么我们的softmax概率计算只需要沿着树形结构进行就可以了。如下图所示，我们可以沿着霍夫曼树从根节点一直走到我们的叶子节点的词w2w2。

 

　　　　和之前的神经网络语言模型相比，我们的霍夫曼树的所有内部节点就类似之前神经网络隐藏层的神经元,其中，根节点的词向量对应我们的投影后的词向量，而所有叶子节点就类似于之前神经网络softmax输出层的神经元，叶子节点的个数就是词汇表的大小。在霍夫曼树中，隐藏层到输出层的softmax映射不是一下子完成的，而是沿着霍夫曼树一步步完成的，因此这种softmax取名为"Hierarchical Softmax"。

　　　　如何“沿着霍夫曼树一步步完成”呢？在word2vec中，我们采用了二元逻辑回归的方法，即规定沿着左子树走，那么就是负类(霍夫曼树编码1)，沿着右子树走，那么就是正类(霍夫曼树编码0)。判别正类和负类的方法是使用sigmoid函数，即：
P(+)=σ(xTwθ)=11+e−xTwθ
P(+)=σ(xwTθ)=11+e−xwTθ
　　　　其中xwxw是当前内部节点的词向量，而θθ则是我们需要从训练样本求出的逻辑回归的模型参数。

　　　　使用霍夫曼树有什么好处呢？首先，由于是二叉树，之前计算量为VV,现在变成了log2Vlog2V。第二，由于使用霍夫曼树是高频的词靠近树根，这样高频词需要更少的时间会被找到，这符合我们的贪心优化思想。

　　　　容易理解，被划分为左子树而成为负类的概率为P(−)=1−P(+)P(−)=1−P(+)。在某一个内部节点，要判断是沿左子树还是右子树走的标准就是看P(−),P(+)P(−),P(+)谁的概率值大。而控制P(−),P(+)P(−),P(+)谁的概率值大的因素一个是当前节点的词向量，另一个是当前节点的模型参数θθ。

　　　　对于上图中的w2w2，如果它是一个训练样本的输出，那么我们期望对于里面的隐藏节点n(w2,1)n(w2,1)的P(−)P(−)概率大，n(w2,2)n(w2,2)的P(−)P(−)概率大，n(w2,3)n(w2,3)的P(+)P(+)概率大。

　　　　回到基于Hierarchical Softmax的word2vec本身，我们的目标就是找到合适的所有节点的词向量和所有内部节点θθ, 使训练样本达到最大似然。那么如何达到最大似然呢？

2. 基于Hierarchical Softmax的模型梯度计算
　　　我们使用最大似然法来寻找所有节点的词向量和所有内部节点θθ。先拿上面的w2w2例子来看，我们期望最大化下面的似然函数：
∏i=13P(n(wi),i)=(1−11+e−xTwθ1)(1−11+e−xTwθ2)11+e−xTwθ3
∏i=13P(n(wi),i)=(1−11+e−xwTθ1)(1−11+e−xwTθ2)11+e−xwTθ3
　　　　对于所有的训练样本，我们期望最大化所有样本的似然函数乘积。

　　　　为了便于我们后面一般化的描述，我们定义输入的词为ww,其从输入层词向量求和平均后的霍夫曼树根节点词向量为xwxw, 从根节点到ww所在的叶子节点，包含的节点总数为lwlw, ww在霍夫曼树中从根节点开始，经过的第ii个节点表示为pwipiw,对应的霍夫曼编码为dwi∈{0,1}diw∈{0,1},其中i=2,3,...lwi=2,3,...lw。而该节点对应的模型参数表示为θwiθiw, 其中i=1,2,...lw−1i=1,2,...lw−1，没有i=lwi=lw是因为模型参数仅仅针对于霍夫曼树的内部节点。

　　　　定义ww经过的霍夫曼树某一个节点j的逻辑回归概率为P(dwj|xw,θwj−1)P(djw|xw,θj−1w)，其表达式为：

P(dwj|xw,θwj−1)={σ(xTwθwj−1)1−σ(xTwθwj−1)dwj=0dwj=1
P(djw|xw,θj−1w)={σ(xwTθj−1w)djw=01−σ(xwTθj−1w)djw=1
　　　　那么对于某一个目标输出词ww,其最大似然为：
∏j=2lwP(dwj|xw,θwj−1)=∏j=2lw[σ(xTwθwj−1)]1−dwj[1−σ(xTwθwj−1)]dwj
∏j=2lwP(djw|xw,θj−1w)=∏j=2lw[σ(xwTθj−1w)]1−djw[1−σ(xwTθj−1w)]djw
　　　　在word2vec中，由于使用的是随机梯度上升法，所以并没有把所有样本的似然乘起来得到真正的训练集最大似然，仅仅每次只用一个样本更新梯度，这样做的目的是减少梯度计算量。这样我们可以得到ww的对数似然函数LL如下：

L=log∏j=2lwP(dwj|xw,θwj−1)=∑j=2lw((1−dwj)log[σ(xTwθwj−1)]+dwjlog[1−σ(xTwθwj−1)])
L=log∏j=2lwP(djw|xw,θj−1w)=∑j=2lw((1−djw)log[σ(xwTθj−1w)]+djwlog[1−σ(xwTθj−1w)])
　　　　要得到模型中ww词向量和内部节点的模型参数θθ, 我们使用梯度上升法即可。首先我们求模型参数θwj−1θj−1w的梯度：

∂L∂θwj−1=(1−dwj)(σ(xTwθwj−1)(1−σ(xTwθwj−1)σ(xTwθwj−1)xw−dwj(σ(xTwθwj−1)(1−σ(xTwθwj−1)1−σ(xTwθwj−1)xw=(1−dwj)(1−σ(xTwθwj−1))xw−dwjσ(xTwθwj−1)xw=(1−dwj−σ(xTwθwj−1))xw(1)(2)(3)
(1)∂L∂θj−1w=(1−djw)(σ(xwTθj−1w)(1−σ(xwTθj−1w)σ(xwTθj−1w)xw−djw(σ(xwTθj−1w)(1−σ(xwTθj−1w)1−σ(xwTθj−1w)xw(2)=(1−djw)(1−σ(xwTθj−1w))xw−djwσ(xwTθj−1w)xw(3)=(1−djw−σ(xwTθj−1w))xw
　　　　如果大家看过之前写的逻辑回归原理小结，会发现这里的梯度推导过程基本类似。

　　　　同样的方法，可以求出xwxw的梯度表达式如下：
∂L∂xw=(1−dwj−σ(xTwθwj−1))θwj−1
∂L∂xw=(1−djw−σ(xwTθj−1w))θj−1w
　　　　有了梯度表达式，我们就可以用梯度上升法进行迭代来一步步的求解我们需要的所有的θwj−1θj−1w和xwxw。

3. 基于Hierarchical Softmax的CBOW模型
　　　　由于word2vec有两种模型：CBOW和Skip-Gram,我们先看看基于CBOW模型时， Hierarchical Softmax如何使用。

　　　　首先我们要定义词向量的维度大小MM，以及CBOW的上下文大小2c2c,这样我们对于训练样本中的每一个词，其前面的cc个词和后面的cc个词作为了CBOW模型的输入,该词本身作为样本的输出，期望softmax概率最大。

　　　　在做CBOW模型前，我们需要先将词汇表建立成一颗霍夫曼树。

　　　　对于从输入层到隐藏层（投影层），这一步比较简单，就是对ww周围的2c2c个词向量求和取平均即可，即：
xw=12c∑i=12cxi
xw=12c∑i=12cxi
　　　　第二步，通过梯度上升法来更新我们的θwj−1θj−1w和xwxw，注意这里的xwxw是由2c2c个词向量相加而成，我们做梯度更新完毕后会用梯度项直接更新原始的各个xi(i=1,2,,,,2c)xi(i=1,2,,,,2c)，即：

θwj−1=θwj−1+η(1−dwj−σ(xTwθwj−1))xw
θj−1w=θj−1w+η(1−djw−σ(xwTθj−1w))xw
xw=xw+η(1−dwj−σ(xTwθwj−1))θwj−1(i=1,2..,2c)
xw=xw+η(1−djw−σ(xwTθj−1w))θj−1w(i=1,2..,2c)
　　　　其中ηη为梯度上升法的步长。

　　　　这里总结下基于Hierarchical Softmax的CBOW模型算法流程，梯度迭代使用了随机梯度上升法：

　　　　输入：基于CBOW的语料训练样本，词向量的维度大小MM，CBOW的上下文大小2c2c,步长ηη
　　　　输出：霍夫曼树的内部节点模型参数θθ，所有的词向量ww
　　　　1. 基于语料训练样本建立霍夫曼树。

　　　　2. 随机初始化所有的模型参数θθ，所有的词向量ww
　　　　3. 进行梯度上升迭代过程，对于训练集中的每一个样本(context(w),w)(context(w),w)做如下处理：

　　　　　　a)  e=0， 计算xw=12c∑i=12cxixw=12c∑i=12cxi
　　　　　　b)  for j = 2 to lwlw, 计算：
f=σ(xTwθwj−1)
f=σ(xwTθj−1w)
g=(1−dwj−f)η
g=(1−djw−f)η
e=e+gθwj−1
e=e+gθj−1w
θwj−1=θwj−1+gxw
θj−1w=θj−1w+gxw
　　　           c) 对于context(w)context(w)中的每一个词向量xixi(共2c个)进行更新：
xi=xi+e
xi=xi+e
　

　　　　　　d) 如果梯度收敛，则结束梯度迭代，否则回到步骤3继续迭代。

4. 基于Hierarchical Softmax的Skip-Gram模型
　　　　现在我们先看看基于Skip-Gram模型时， Hierarchical Softmax如何使用。此时输入的只有一个词ww,输出的为2c2c个词向量context(w)context(w)。

　　　　我们对于训练样本中的每一个词，该词本身作为样本的输入， 其前面的cc个词和后面的cc个词作为了Skip-Gram模型的输出,，期望这些词的softmax概率比其他的词大。

　　　　Skip-Gram模型和CBOW模型其实是反过来的，在上一篇已经讲过。

　　　　在做CBOW模型前，我们需要先将词汇表建立成一颗霍夫曼树。

　　　　对于从输入层到隐藏层（投影层），这一步比CBOW简单，由于只有一个词，所以，即xwxw就是词ww对应的词向量。

　　　　第二步，通过梯度上升法来更新我们的θwj−1θj−1w和xwxw，注意这里的xwxw周围有2c2c个词向量，此时如果我们期望P(xi|xw),i=1,2...2cP(xi|xw),i=1,2...2c最大。此时我们注意到由于上下文是相互的，在期望P(xi|xw),i=1,2...2cP(xi|xw),i=1,2...2c最大化的同时，反过来我们也期望P(xw|xi),i=1,2...2cP(xw|xi),i=1,2...2c最大。那么是使用P(xi|xw)P(xi|xw)好还是P(xw|xi)P(xw|xi)好呢，word2vec使用了后者，这样做的好处就是在一次迭代时，我们不是更新xwxw一个词，而是xi,i=1,2...2cxi,i=1,2...2c共2c2c个词。这样整体的迭代会更加的均衡。因为这个原因，Skip-Gram模型并没有和CBOW模型一样对输入进行迭代更新，而是对2c2c个输出进行迭代更新。

　　　　这里总结下基于Hierarchical Softmax的Skip-Gram模型算法流程，梯度迭代使用了随机梯度上升法：

　　　　输入：基于Skip-Gram的语料训练样本，词向量的维度大小MM，Skip-Gram的上下文大小2c2c,步长ηη
　　　　输出：霍夫曼树的内部节点模型参数θθ，所有的词向量ww
　　　　1. 基于语料训练样本建立霍夫曼树。

　　　　2. 随机初始化所有的模型参数θθ，所有的词向量ww,

　　　　3. 进行梯度上升迭代过程，对于训练集中的每一个样本(w,context(w))(w,context(w))做如下处理：

　　　　　　a)  for i =1 to 2c:

　　　　　　　　i) e=0

                              ii)for j = 2 to lwlw, 计算：
f=σ(xTiθwj−1)
f=σ(xiTθj−1w)
g=(1−dwj−f)η
g=(1−djw−f)η
e=e+gθwj−1
e=e+gθj−1w
θwj−1=θwj−1+gxi
θj−1w=θj−1w+gxi
　　　　　　　　iii) 
xi=xi+e
xi=xi+e
　　　　　　b)如果梯度收敛，则结束梯度迭代，算法结束，否则回到步骤a继续迭代。

5. Hierarchical Softmax的模型源码和算法的对应　　　　
　　　　这里给出上面算法和word2vec源码中的变量对应关系。

　　　　在源代码中，基于Hierarchical Softmax的CBOW模型算法在435-463行，基于Hierarchical Softmax的Skip-Gram的模型算法在495-519行。大家可以对着源代码再深入研究下算法。

　　　　在源代码中，neule对应我们上面的ee, syn0对应我们的xwxw, syn1对应我们的θij−1θj−1i, layer1_size对应词向量的维度，window对应我们的cc。

　　　　另外，vocab[word].code[d]指的是，当前单词word的，第d个编码，编码不含Root结点。vocab[word].point[d]指的是，当前单词word，第d个编码下，前置的结点。

　　

　　　　以上就是基于Hierarchical Softmax的word2vec模型，下一篇我们讨论基于Negative Sampling的word2vec模型。